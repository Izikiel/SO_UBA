\documentclass{article}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\title{Algoritmos y Estructuras de Datos III \\ Trabajo Pr\'{a}ctico 1}
\author{Mart\'{i}n Arjovsky 683/12\\ Ezequiel Dar\'io Gambaccini \\ Silvio Vileri\~no}
\date{Abril 2014}

\begin{document}
 \maketitle
  
  \section{Ejercicio 2}
  
  A continuaci\'on se muestran los gr\'aficos del lote 2 para 1, 2 y 3 n\'ucleos.
  \begin{figure}[htb]
  \includegraphics[scale=0.32]{ej2_1.png}
  \caption{Diagrama de Gantt para el lote 2 en FCFS con un n\'ucleo}
  \end{figure}
  \begin{figure}[htb]
  \includegraphics[scale=0.32]{ej2_2.png}
  \caption{Diagrama de Gantt para el lote 2 en FCFS con dos n\'ucleos}
  \end{figure}
  \begin{figure}[htb]
  \includegraphics[scale=0.32]{ej2_3.png}
  \caption{Diagrama de Gantt para el lote 2 en FCFS con tres n\'ucleos}
  \end{figure}
 
  \section{Ejercicio 4}
  
  A continuaci\'on se muestran los gr\'aficos del lote 4 ejecutado en el scheduler Round-Robin.
  \begin{figure}[htb]
  \includegraphics[scale=0.32]{ej4_1.png}
  \caption{Diagrama de Gantt para el lote 4 en RR con un n\'ucleo}
  \end{figure}
  \begin{figure}[htb]
  \includegraphics[scale=0.32]{ej4_2.png}
  \caption{Diagrama de Gantt para el lote 4 en RR con dos n\'ucleos}
  \end{figure}
  
  En ambos gr\'aficos se observa el comportamiento esperado de un scheduler de tipo Round-Robin. En particular, en la figura 4 se ve como la tarea 0 corre en el \'unico n\'ucleo hasta que en el tiempo 4 se le acaba
  el quantum disponible y el scheduler busca otro proceso disponible en la cola global. Tambi\'en se muestra repetidamente como cuando un proceso realiza una llamada bloqueante, el CPU deja esa tarea para ir a ejecutar
  otra. En la figura 5 se observa el mismo comportamiento, pero adem\'as podemos observar la migraci\'on de procesos entre n\'ucleos, por ejemplo a tiempo 16 en la tarea 2.
  
  \section{Ejercicio 8}
  
  A continuaci\'on se muestran los gr\'aficos del lote 8 ejecutado sobre los schedulers Round-Robin con y sin migraci\'on entre procesos.
  
  \begin{figure}
  \includegraphics[scale=0.32]{ej8_RR.png}
  \caption{Diagrama de Gantt para el lote 8 en RR con dos n\'ucleos}
  \end{figure}
  
  \begin{figure}
  \includegraphics[scale=0.32]{ej8_RR2.png}
  \caption{Diagrama de Gantt para el lote 8 en RR2 con dos n\'ucleos}
  \end{figure}
 
  Se puede observar en el caso donde hay tareas con considerable diferencia de duracion, una mejor performance del scheduler RR1, dado que realiza una correccion permanente del balanceo de carga usando los recursos que tiene a su alcance en cada tick. Mientras que en el RR2, al quedar fija la afinidad al momento del dispatch, si ocurre un caso donde ambas tareas cortas quedan en un core y las tareas largas en otro core, al finalizar las tareas cortas, se desperdiciara un core durante toda la ejecucion de las tareas largas.
  Esta diferencia se ve claramente en los gr
\end{document}
